# Node.js 3장 Chapter Express 01~17

## 01 수업 소개

**Node.js 등장** → 웹 브라우저에서 사용하던 기술인 자바스크립트를 그대로 서버 쪽에서 사용할 수 있게 됨.

**웹 프레임워크 등장**→ URL파라미터를 통해 전달된 데이터를 받아서 무언가를 처리하는일, 정적인 자바스크립트 파일, 이미지 파일 등을 사용자에게 제공하는 기능, 로그인 기능, 보안 기능 등과 같이 반복적으로 어디서나 등장하는 기능을 처리할 때 더 적은 코드와 지식으로도 더 많은 일을 안전하게 처리할 수 있게 됨. 

익스프레스(express): Node.js위에서 동작하는 여러 프레임워크 중 하나

## 02 실습 준비

비주얼스튜디오 코드 → [File] → [Add Folder to Workspace] → express 폴더 선택하여 프로젝트 폴더로 지정

터미널 창

```jsx
> pm2 start main.js --watch  //프로세스 관리자인 pm2를 이용해서 main.js파일 실행, --watch는 main.js이 수정될 때마다 pm2가 자동으로 재실행하면서 소스의 변화를 반영해줌
> pm2 log //로그 활성화-> 실행 과정에서 오류가 발생하는지 등을 확인

-->웹 브라우저에서 localhost:3000해보면 오류 뜸-> sanitize-html 모듈이 설치되지 않았기 때문

> npm install // 모듈 설치
> pm2 stop main
> pm2 start main.js --watch
> pm2 log

-->웹 페이지가 제대로 실행됨.
```

## 03 Hello World

### 익스프레스 설치 및 Hello World실행하기

```jsx
> npm install express --save // npm으로 express설치
--> 익스프레스 설치하면 프로젝트 아래의 node_modules디렉터리에 express디렉터리가 생성됨.
```

- 익스프레스의 사용법은 공식 홈페이지의 Getting started에 나와있음

### 익스프레스 사용 준비

```jsx
//기존의 main.js코드 내용 주석으로 처리하고 입력

var express=require('express') // require를 사용해서 불러온 이유: 익스프레스도 모듈이기 떄문
var app=express()//express()를 함수로 호출, express()함수가 반환하는 값은 익스프레스 프레임워크에서 제공하는 Application이라는 객체, 이 값을 app이라는 변수에 저장

// app객체에 포함된 메서드 중 get과 listen을 호출하는 코드
app.get('/',function(req,res){return res.send('Hello World!')}); // 경로에 홈 페이지를 의미하는 /를 전달, 콜백함수에는 해당 경로에 접속했을 떄 호출할 함수를 지정. 즉, 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/page',function(req,res) {res.send('/page')}); // get메서드를 추가하여 다른 경로에 응답 --> localhost:3000/page에도 응답
app.listen(3000,function() {console.log('Example app listening on port 3000')});// listen이라는 메서드가 실행될 때 웹 서버가 실행되며, 3000포트로 사용자의 요청을 받을 수 있게 됨. = 기존 코드의 app.listen(3000)
```

⇒ 웹 브라우저에서 localhost:3000접속하면 Hello World!가 출력됨.

- const: 상수(constant)라는 뜻으로 바뀌지 않는 값, express변수 앞에 const를 사용함으로써 express모듈을 저장한 이후에는 값을 변경할 수 없게 고정한 것. 여기에서는 const를 var로 바꿔서 사용
- get 메서드의 콜백함수 부분 (req,res)=> res.send('Hello World!') —> function(req,res){return res.send('Hello World!')} 옛날 방식으로 바꿈(문법적인 복잡도 줄이기 위해)

### get 메서드)

- 라우팅 기능 : 어떤 길을 따라 진행하다가 갈림길에서 방향을 잡아주는 것 의미(사용자들이 여러 경로로 들어올 때 경로마다 응답해주는 기능)
- get 메서드 호출 형태:

```jsx
app.get(path,callback[,callback ..])
// get 메서드의 첫 번째 인자에는 경로, 두 번째 인자에는 콜백 함수 전달
```

**—> 앞에서 주석으로 처리한 부분 기존의 코드에서는 라우팅 기능을 if~else같은 분기문으로 처리했던 것. 현재는 app.get메서드를 이용한 방식 사용한 것.**

## 04 홈페이지 구현

```jsx
**// 기존 코드**
 if(pathname === '/') {
        if(queryData.id === undefined) {
            fs.readdir('./data', function(error, filelist) {
                var title = 'Welcome';
                var description = 'Hello, Node.js';
                var list = template.list(filelist);
                var html = template.HTML(title, list,
                    `<h2>${title}</h2><p>${description}</p>`,
                    `<a href="/create">create</a>`
                );
                response.writeHead(200);
                response.end(html);
            });
        } ...생략
        
        
        
**// 익스프레스 프레임워크 사용하여 수정**
var express=require('express')
var app=express()
var fs = require('fs');
var template = require('./lib/template.js');

//app.get('/',function(req,res) {res.send('Hello World!')}); // 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/', function(request,response){
    fs.readdir('./data',function(error,filelist){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(filelist);
            var html = template.HTML(title, list,
                `<h2>${title}</h2><p>${description}</p>`,
                `<a href="/create">create</a>`
            );
            response.send(html);
    });
});

app.get('/page',function(req,res) {res.send('/page')}); 

app.listen(3000,function() {console.log('Example app listening on port 3000')});
```

- 콜백 함수의 매개변수 이름을 request와 response처럼 전체 이름으로 바꿈.
- 기존의 response의 writeHead와 end메서드 호출을 지우고 send메서드를 한 번 호출하는 코드로 변경.

## 05 상세 보기 페이지 구현

홈에 나열된 글 목록에서 하나를 클릭했을 때 해당 내용이 보이게 상세 보기 페이지 구현하기

기존 웹 페이지는 글 목록에서 사용자가 클릭한 글에 해당하는 **쿼리 스트링을 전달**함. (HTML을 클릭하면 ?id=HTML이라는 쿼리 스트링을 전달, 그러면 웹 애플리케이션은 data디렉터리 안에서 전달받은 쿼리 스트링에 해당하는 파일을 찾아서 응답)

—> **시맨틱 URL 방식 사용하여 전달**

### 시맨틱 URL(semantic URL) 방식)

질의어 없이 경로만 가진 간단한 구조의 URL

```jsx
//시맨틱 URL의 예
?id=HTML  --> page/HTML
```

익스프레스 라우트 가이드의 시맨틱 URL처리 방식

```jsx
Route path: /users/:userId/:books/:bookId
Request URL: http://localhost:3000/users/34/books/8989
req.params:{"userId":"34","bookId":"8989"}

// 경로에서 users다음에 :userId라고 지정함으로써 사용자가 요청한 URL을 req.params를 이용해 '키:값'형태로 가져올 수 있다고 소개
```

시맨틱 URL방식 사용하도록 코드 수정

```jsx
//익스프레스의 라우트 가이드에 따라 사용자가 요청한 URL가져오기
app.get('/page/:pageId',function(request,response) {response.send(request.params)}); 
```

**상세 보기 페이지 구현**

```jsx
// 수정전
else {
            fs.readdir('./data', function(error, filelist) {
                var filteredId = path.parse(queryData.id).base;
                fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
                    var title = queryData.id;
                    var sanitizedTitle = sanitizeHtml(title);
                    var sanitizedDescription = sanitizeHtml(description, {
                        allowedTags:['h1']
                    });
                    var list = template.list(filelist);
                    var html = template.HTML(sanitizedTitle, list,
                        `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                        `<a href="/create">create</a>
                        <a href="/update?id=${sanitizedTitle}">update</a>
                        <form action="delete_process" method="post">
                            <input type="hidden" name="id" value="${sanitizedTitle}">
                            <input type="submit" value="delete">
                        </form>`
                    );
                    response.writeHead(200);
                    response.end(html);
                });
            });
        }
    } 
    
    
    // 수정 후
    var path = require('path');
    var sanitizeHtml = require('sanitize-html');
    
    app.get('/page/:pageId',function(request,response) {
    fs.readdir('./data', function(error, filelist) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(filelist);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/create">create</a>
                <a href="/update?id=${sanitizedTitle}">update</a>
                <form action="delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
    });
  });
}); 
```

- 기존 코드에서 path와 sanitize-html모듈을 불러옴.
- 쿼리 스트링 대신 매개변수를 이용하므로 queryData.id부분을 request.params.pageId로 변경.

http://localhost:3000/page/HTML 에 접속하면 제대로 접속되지만 홈에서 글 목록 중 HTML을 클릭하면 쿼리 스트링(?id=HTML)을 전달하므로 이 부분 수정하기

**template.js파일의 list함수 수정**

```jsx
//수정전
list:function(filelist) {
        var list = '<ul>';
        var i = 0;
        while(i < filelist.length) {
            list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
            i = i + 1;
        }
        list = list+'</ul>';
        return list;
    }
    
    // 수정후
    
    list:function(filelist) {
        var list = '<ul>';
        var i = 0;
        while(i < filelist.length) {
            list = list + `<li><a href="/page/${filelist[i]}">${filelist[i]}</a></li>`;
            i = i + 1;
        }
        list = list+'</ul>';
        return list;
    }
```

## 06 페이지 생성 구현

사용자가 [create]버튼을 클릭했을 때 보여줄 글 작성 페이지 만들고, 거기에서[submit]버튼을 클릭했을 때 글을 생성하는 기능 구현

main.js

```jsx
//수정전
else if(pathname === '/create') {
        fs.readdir('./data', function(error, filelist) {
            var title = 'WEB - create';
            var list = template.list(filelist);
            var html = template.HTML(title, list, `
                <form action="/create_process" method="post">
                    <p><input type="text" name="title" placeholder="title"></p>
                    <p>
                        <textarea name="description" placeholder="description"></textarea>
                    </p>
                    <p>
                        <input type="submit">
                    </p>
                </form>
            `, '');
            response.writeHead(200);
            response.end(html);
        });
    } else if(pathname === '/create_process') {
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var title = post.title;
            var description = post.description;
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
    }

**// 수정후
// 새 글을 작성하는 페이지 구현**
app.get('/create',function(request,response){
    fs.readdir('./data', function(error, filelist) {
        var title = 'WEB - create';
        var list = template.list(filelist);
        var html = template.HTML(title, list, `
            <form action="/create_process" method="post">
                <p><input type="text" name="title" placeholder="title"></p>
                <p>
                    <textarea name="description" placeholder="description"></textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
        `, '');
        response.send(html);
    });
});

**// 새 글을 생성하는 create_process구현**
var qs = require('querystring');

app.post('/create_process', function(request,response){
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var title = post.title;
            var description = post.description;
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
});

```

- create_process는 전달 방식이 post이므로 app.post메서드를 사용한 것.

## 07 페이지 수정 구현

사용자가 상세 보기 페이지에서 [update]를 클릭했을 때 보여줄 페이지와 거기서[submit]버튼을 클릭했을 때 글을 수정하는 기능 구현

쿼리 스트링 —> 시맨틱 URL사용하도록 update링크 부분 수정

```jsx
//수정전
<a href="/update?id=${sanitizedTitle}">update</a>

//수정후
<a href="/update/${sanitizedTitle}">update</a>
```

main.js

```jsx
**//수정전**
else if(pathname === '/update') {
        fs.readdir('./data', function(error, filelist) {
            var filteredId = path.parse(queryData.id).base;
            fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
                var title = queryData.id;
                var list = template.list(filelist);
                var html = template.HTML(title, list,
                    `
                    <form action="/update_process" method="post">
                        <input type="hidden" name="id" value="${title}">
                        <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                        <p>
                            <textarea name="description" placeholder="description">${description}</textarea>
                        </p>
                        <p>
                            <input type="submit">
                        </p>
                    </form>
                    `,
                    `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
                );
                response.writeHead(200);
                response.end(html);
            });
        });
    } else if(pathname === '/update_process') {
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var id = post.id;
            var title = post.title;
            var description = post.description;
            fs.rename(`data/${id}`, `data/${title}`, function(error) {
                fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                    response.writeHead(302, {Location: `/?id=${title}`});
                    response.end();
                });
            });
        });
    }
    
    
 **// 수정후
 //글을 수정하는 페이지 구현**
 app.get('/update/:pageId',function(request,response){
    fs.readdir('./data', function(error, filelist) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var list = template.list(filelist);
            var html = template.HTML(title, list,
                `
                <form action="/update_process" method="post">
                    <input type="hidden" name="id" value="${title}">
                    <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                    <p>
                        <textarea name="description" placeholder="description">${description}</textarea>
                    </p>
                    <p>
                        <input type="submit">
                    </p>
                </form>
                `,
                `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
            );
            response.send(html);
        });
  });
});

**//글을 수정하는 update_process 구현**
app.post('/update_process',function(request,response){
    var body = '';
    request.on('data', function(data) {
        body = body + data;
    });
    request.on('end', function() {
        var post = qs.parse(body);
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
    });
});

```

- 경로에 :pageId를 사용, 기존 코드에서 queryData.id대신 request.params를 사용

- **params:** Express.js의 라우팅에서 URL의 경로에 변수를 삽입 가능. 이 변수들은 클라이언트 요청에서 동적으로 값을 받을 수 있으며, 이 값들은 **‘request.params’객체**를 통해 접근 가능.

## 08 페이지 삭제 구현

사용자가 상세 보기 페이지에서 [delete]버튼을 클릭했을 때 글을 삭제하는 기능 구현

쿼리 스트링 —> 시맨틱 URL사용하도록 delete링크 부분 수정

```jsx
//수정전
<form action="delete_process" method="post">

//수정후
<form action="/delete_process" method="post">
```

```jsx
**//수정전**
else if(pathname === '/delete_process') {
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.writeHead(302, {Location: `/`});
                response.end();
            });
        });
        
  **//수정후      
  //글을 삭제하는 delete_process구현**
  app.post('/delete_process',function(request,response){
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
        });
    });
```

- **리다이렉트 처리 부분 :** 익스프레스 프레임워크는 리다이렉트를 편리하게 하는 기능을 지원 —> **respose.redirect만 호출**하면 되므로 기존 코드와 비교했을 때 더 깔끔해짐.

글을 수정하는 부분에도 리다이렉트 기능 적용

```jsx
//수정전
app.post('/update_process',function(request,response){
    var body = '';
    request.on('data', function(data) {
        body = body + data;
    });
    request.on('end', function() {
        var post = qs.parse(body);
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                **response.writeHead(302, {Location: `/?id=${title}`}); // 이부분
                response.end();**
            });
        });
    });
});

//수정후
app.post('/update_process',function(request,response){
    var body = '';
    request.on('data', function(data) {
        body = body + data;
    });
    request.on('end', function() {
        var post = qs.parse(body);
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
               **response.redirect('/'); // 이부분**
            });
        });
    });
});
```

수정된 main.js 전체

```jsx
var express=require('express')
var app=express()
var fs = require('fs');
var template = require('./lib/template.js');
var path = require('path');
var sanitizeHtml = require('sanitize-html');
var qs = require('querystring');

//app.get('/',function(req,res) {res.send('Hello World!')}); // 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/', function(request,response){
    fs.readdir('./data',function(error,filelist){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(filelist);
            var html = template.HTML(title, list,
                `<h2>${title}</h2><p>${description}</p>`,
                `<a href="/create">create</a>`
            );
            response.send(html);
    });
});

//app.get('/page',function(req,res) {res.send('/page')}); 
app.get('/page/:pageId',function(request,response) {
    fs.readdir('./data', function(error, filelist) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(filelist);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/create">create</a>
                <a href="/update/${sanitizedTitle}">update</a>
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
    });
  });
}); 

// 새 글을 작성하는 페이지 구현
app.get('/create',function(request,response){
    fs.readdir('./data', function(error, filelist) {
        var title = 'WEB - create';
        var list = template.list(filelist);
        var html = template.HTML(title, list, `
            <form action="/create_process" method="post">
                <p><input type="text" name="title" placeholder="title"></p>
                <p>
                    <textarea name="description" placeholder="description"></textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
        `, '');
        response.send(html);
    });
});

//새 글을 생성하는 create_process구현
app.post('/create_process', function(request, response){
    var body = '';
    request.on('data', function(data){
        body = body + data;
    });
    request.on('end', function(){
        var post = qs.parse(body);
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
          response.writeHead(302, {Location: `/?id=${title}`});
          response.end();
        })
     });
  });

  //글을 수정하는 페이지 구현
  app.get('/update/:pageId',function(request,response){
    fs.readdir('./data', function(error, filelist) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var list = template.list(filelist);
            var html = template.HTML(title, list,
                `
                <form action="/update_process" method="post">
                    <input type="hidden" name="id" value="${title}">
                    <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                    <p>
                        <textarea name="description" placeholder="description">${description}</textarea>
                    </p>
                    <p>
                        <input type="submit">
                    </p>
                </form>
                `,
                `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
            );
            response.send(html);
        });
    });
});

//글을 수정하는 update_process구현
app.post('/update_process',function(request,response){
    var body = '';
    request.on('data', function(data) {
        body = body + data;
    });
    request.on('end', function() {
        var post = qs.parse(body);
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
    });
});

// 글을 삭제하는 delete_process구현
app.post('/delete_process',function(request,response){
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
        });
    });

app.listen(3000,function() {console.log('Example app listening on port 3000')});

```

⇒ Node.js로 만들었던 애플리케이션을 익스프레스 버전으로 변경하여 본 것.

변경되는 코드 대부분은 **라우트 기능,** 사용자 요청별로 어떻게 응답할지, get이나 post방식으로 요청받았을 때 어떻게 구분해서 응답할 것인가 등 살펴봐야 함. 

## 09 익스프레스 미들웨어 사용하기

### 익스프레스의 핵심 기능)

1. **라우터 기능**

      **:** URL경로에 따라 요청을 처리할 핸들러를 정의하고 관리하는 기능.

1. **미들웨어(middleware) 기능**

      **:** 여러 사람이 개발한 소프트웨어를 이용하여 생산성을 높이려고 할         때 사용하는 기능

    : 요청과 응답 사이에서 코드의 재사용과 처리를 담당하는 함수로, 요청을 처리하거나 응답을 수정하는 기능을 제공하는 기능.

```jsx
app.post('/create_process', function(request, response){
    var body = '';
    request.on('data', function(data){
        body = body + data;
    });
    request.on('end', function(){
        var post = qs.parse(body);
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
          response.writeHead(302, {Location: `/?id=${title}`});
          response.end();
        })
     });
  });
  
--> 사용자가 입력한 정보는 POST방식으로 전달되므로 GET방식과는 다르게 데이터의 크기가 클 수 있음
**data라는 이벤트가 발생할 때마다 body변수에 데이터를 추가하다가 end이벤트가 발생하면 body변수에 담긴 데이터를 처리하는 방식**

```

서드파티 미들웨어: 남이 만든 미들웨어라는 의미

### body-parser 미들웨어 사용하기

설치

```jsx
>npm install body-parser --save
```

**body-parser:** 요청 정보의 본문을 해석해서 우리에게 필요한 형태로 가공해주는 프로그램

- 간결하고 안정적인 코드 작성 가능.
- body: 웹 브라우저에서 요청한 정보의 본문 의미

```jsx
var bodyParser = require('body-parser'); // body-parser모듈 불러오기

app.use(bodyParser.urlencoded({extended:false})); 
// 익스프레스의 use메서드에 body-parser라는 미들웨어 전달 --> 해당 미들웨어가 실행되고 그 결과를 전달받음.

```

- 즉, main.js가 실행될 때마다(사용자의 요청이 있을 때마다)미들웨어가 실행됨.
- 사용자가 POST방식으로 전송한 데이터를 내부적으로 분석해서 우리가 만든 create_process와 같은 동작을 한 다음, 그 결과를 전달.
- create_process에 정의한 콜백 함수의 첫 번째 매개변수(request)를 이용하여 body-parser가 만들어준 데이터를 활용하면 됨.

**create_process, update_process, delete_process에서 body-parser가 만들어준 데이터를 이용하는 방식으로 수정**

```jsx
**//수정전**
app.post('/create_process', function(request, response){
    var body = '';
    request.on('data', function(data){
        body = body + data;
    });
    request.on('end', function(){
        var post = qs.parse(body);
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
          response.writeHead(302, {Location: `/?id=${title}`});
          response.end();
        })
     });
  });
  
  app.post('/update_process',function(request,response){
    var body = '';
    request.on('data', function(data) {
        body = body + data;
    });
    request.on('end', function() {
        var post = qs.parse(body);
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
    });
});

app.post('/delete_process',function(request,response){
        var body = '';
        request.on('data', function(data) {
            body = body + data;
        });
        request.on('end', function() {
            var post = qs.parse(body);
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
        });
    });
  
  
  **//수정후**
  app.post('/create_process', function(request, response){
        var post = request.body;
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
          response.writeHead(302, {Location: `/?id=${title}`});
          response.end();
        });
  });
  
  
app.post('/update_process',function(request,response){
        var post = request.body;
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
});

app.post('/delete_process',function(request,response){
            var post = request.body;   
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
    });
```

- 기존 코드에서 data이벤트가 발생할 때마다 요청 데이터를 가져오는 코드를 지움.
- end이벤트가 발생했을 때 처리하는 로직에서 데이터 소스만 request.body로 변경, request.body속성에는 body-parser가 만들어 준 데이터가 들어있음.

### compression  미들웨어 사용하기

ex) 웹 브라우저에서 [localhost:3000/](http://localhost:3000/dp)에 접속하여 create를 눌러 express제목의 아주 긴 내용을 생성했을 때 이 파일의 크기가 30kb이라면?

—> 웹 사이트에 수많은 사용자가 접속하고, 이보다 큰 데이터를 내려받는다면 비용과 시간 많이 들 것. 

해결방법: 웹 서버가 웹 브라우저에 응답할 때 해당 데이터를 **압축**해서 보낼 수 있음, 웹 브라우저가 압축된 데이터를 받아서 웹 서버가 지정해준 압축 방식으로 압축을 풀어서 사용자에게 보여줌.

**compression:** 압축과 관련된 미들웨어

설치

```jsx
>npm install compression --save
```

```jsx
var compression = require('compression'); //compression 모듈 불러오기

app.use(compression());
// use메서드를 이용하여 compression함수 호출
// compression()모듈을 호출하면 미들웨어를 리턴하게 약속돼 있고, 이 미들웨어가 app.use()메서드를 통해 장착되는 것
// 애플리케이션은 사용자 요청이 있을 때마다 body-parser미들웨어와 compression미들웨어를 실행하게 되는 것.
```

—> 용량이 줄어듦.  웹 브라우저에서 개발자 도구에서 Express누르고 [Response Header]에서 [Content-Encoding]항목을 보면 gzip이라고 표시되어 있음.  gzip방식으로 압축되었다는 의미.

## 10 익스프레스 미들웨어 만들기

직접 미들웨어 만들어서 사용해보기

사용법)

- app.use메서드에 어떤 변수를 넘김, 이 변수는 위에 정의된 함수
- 함수의 매개변수는 req, res객체와 next함수

```jsx
// main.js파일에서 반복 사용되는 글 목록 표현 코드
fs.readdir('./data', function(error,filelist){

// 미들웨어로 만들어서 처리하기
//수정1. 미들웨어 만들기
app.use(bodyPaser.urlencoded({extend:false}));
app.use(function(requeset,response,next){
});

//수정2. 콜백 함수 안에 반복해서 사용한 로직을 작성
app.use(function(requeset,response,next){
    fs.readdir('./data',function(error,filelist){
        request.list = filelist;
        next();
    });
});

//수정3. next함수의 동작 확인
app.use(function(requeset,response,next){
    fs.readdir('./data',function(error,filelist){ // 데이터 디렉토리에 있는 파일 목록을 가져와서 파일리스트라는 변수가 세팅이 되고 function이 호출이 됨.
        request.list = filelist; //request객체에 list라는 변수를 filelist값으로 줄 것.
        next(); // 그다음에 호출되어야 할 미들웨어가 담겨있음. 
    });
});

app.get('/page/:pageId', function(request,response){
    console.log(request.list);//이거 추가해서 콘솔 창 보면 [
0|main   |   'CSS',
0|main   |   'CSS3',
0|main   |   'dirty HTML',
0|main   |   'Express',
0|main   |   'HTML',
0|main   |   'JavaScript',
0|main   |   'Nodejs',
0|main   |   'XSS'
0|main   | ] 
이렇게 배열이 출력됨

```

- 배열 출력 —> 미들웨어에서 request.list에 설정한 값으로 모든 라우트 안에서 request.list속성을 이용하여 글 목록에 접근 가능.

fs.readdir 콜백 제거, filelist를 request.list로 수정

```jsx

var express=require('express')
var app=express()
var fs = require('fs');
var template = require('./lib/template.js');
var path = require('path');
var sanitizeHtml = require('sanitize-html');
var qs = require('querystring');
var bodyParser = require('body-parser'); //body-parser 모듈 불러오기
var compression = require('compression'); //compression 모듈 불러오기

app.use(bodyParser.urlencoded({extended:false})); // 익스프레스의 use메서드에 body-parser라는 미들웨어 전달 --> 해당 미들웨어가 실행되고 그 결과를 전달받음.
app.use(compression());

app.get('*',function(request,response,next) {
    fs.readdir('./data',function(error,filelist){ // 데이터 디렉토리에 있는 파일 목록을 가져와서 파일리스트라는 변수가 세팅이 되고 function이 호출이 됨.
        request.list = filelist; //request객체에 list라는 변수를 filelist값으로 줄 것.
        next(); // 그다음에 호출되어야 할 미들웨어가 담겨있음. 
    });
});

//app.get('/',function(req,res) {res.send('Hello World!')}); // 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/', function(request,response){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(request.list);
            var html = template.HTML(title, list,
                `<h2>${title}</h2><p>${description}</p>`,
                `<a href="/create">create</a>`
            );
            response.send(html);
});

//app.get('/page',function(req,res) {res.send('/page')}); 
app.get('/page/:pageId',function(request,response) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/create">create</a>
                <a href="/update/${sanitizedTitle}">update</a>
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
    });
}); 

// 새 글을 작성하는 페이지 구현
app.get('/create',function(request,response){
        var title = 'WEB - create';
        var list = template.list(request.list);
        var html = template.HTML(title, list, `
            <form action="/create_process" method="post">
                <p><input type="text" name="title" placeholder="title"></p>
                <p>
                    <textarea name="description" placeholder="description"></textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
        `, '');
        response.send(html);
});

//새 글을 생성하는 create_process구현
app.post('/create_process', function(request, response){
    console.log(request.list);
        var post = request.body;
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
          response.writeHead(302, {Location: `/?id=${title}`});
          response.end();
        });
  });

  //글을 수정하는 페이지 구현
  app.get('/update/:pageId',function(request,response){
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var list = template.list(filelist);
            var html = template.HTML(title, list,
                `
                <form action="/update_process" method="post">
                    <input type="hidden" name="id" value="${title}">
                    <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                    <p>
                        <textarea name="description" placeholder="description">${description}</textarea>
                    </p>
                    <p>
                        <input type="submit">
                    </p>
                </form>
                `,
                `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
            );
            response.send(html);
        });
});

//글을 수정하는 update_process구현
app.post('/update_process',function(request,response){
        var post = request.body;
        var id = post.id;
        var title = post.title;
        var description = post.description;
        fs.rename(`data/${id}`, `data/${title}`, function(error) {
            fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
                response.writeHead(302, {Location: `/?id=${title}`});
                response.end();
            });
        });
});

// 글을 삭제하는 delete_process구현
app.post('/delete_process',function(request,response){
            var post = request.body;   
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
    });

app.listen(3000,function() {console.log('Example app listening on port 3000')});
```

- 문제: 글 목록을 읽어와야 하는 상황은 main.js에 정의된 여러 가지 메서드 중 몇 개뿐, process가 붙는 요청에서는 파일 목록 읽어올 필요 없는데도 모든 요청이 있을 때마다 미들웨어가 실행되므로 비효율적임.

- 해결: **미들웨어를 정의한 부분에서 use메서드 대신 get메서드를 사용.**

```jsx
app.get(function(request,response,next) {   **//use --> get**
    fs.readdir('./data',function(error,filelist){ // 데이터 디렉토리에 있는 파일 목록을 가져와서 파일리스트라는 변수가 세팅이 되고 function이 호출이 됨.
        request.list = filelist; //request객체에 list라는 변수를 filelist값으로 줄 것.
        next(); // 그다음에 호출되어야 할 미들웨어가 담겨있음. 
    });
});
```

- 모든 요청이 아닌 GET방식으로 전송하는 요청일 때만 미들웨어 실행
- 두 번째 인수로 전달한 콜백: 미들웨어

—>main.js파일에서 body-parser부터 compression, 파일 목록 가져오기, 각 요청에 따른 라우트 기능까지 모두 미들웨어로 만들어졌다고 볼 수 있음.

**⇒ 애플리케이션이 구동될 때 순서대로 등록된 작은 프로그램들이 실행되는데, 각 프로그램이 서로와 서로를 연결해주는 작은 소프트웨어라는 점에서 미들웨어라는 표현을 씀.** 

## 11 미들웨어의 실행 순서

### 미들웨어 타입

- **애플리케이션 레벨 미들웨어:** app이라는 변수에 express애플리케이션의 객체가 담겨 있고, 이 객체의 use, get, post메서드를 호출해서 미들웨어를 이용
- **라우터 레벨 미들웨어**
- **에러 핸들링 미들웨어**
- **내장 미들웨어**
- **서드파티 미들웨어:** 데이터를 압축해주는 compression과 본문을 분석해주는 body-parser미들웨어

### 애플리케이션 레벨 미들웨어

```jsx
var app = express()

app.use(function(req, res, next) {
  console.log('TIme:', Data.now())
  next()
})
```

1. app객체의 use메서드에 콜백 함수를 정의하는  것으로 시작.
2. 콜백 함수의 매개변수인 요청과 응답 객체를 받아서 활용 가능
3. next 함수를 이용해서 그다음 미들웨어의 실행 여부를 이전 미들웨어에서 호출 여부로 결정 가능
4. use메서드의 첫 번째 인수로 경로를 넘겨줌으로써 해당 미들웨어가 특정 경로에서만 동작하게 가능

```jsx
app.use('/user/:id', function(req,res,next){
  console.log('Request Type:', req.method)
  next()
 })
```

1. GET이나 POST등 전송 방식에 따라 미들웨어가 동작하게 가능 

```jsx
app.get('/user/:id',function(req,res,next){
  res.send('UESR')
})
```

예시) use메서드에 콜백 함수 2개를 연속으로 정의

```jsx
app.use('/user/:id', function(req,res,next){
  console.log('Request URL:' , req,originalUrl)
  next()
}, function(req,res,next) {
  console.log('Request Type:', req.method)
  next()
})
```

- 첫 번째 콜백 함수에 있는 next함수는 두 번째 콜백 함수를 호출하는 것과 같음.

경우1)

```jsx
app.use('/user/:id', function(req,res,next){
  console.log('ID: ',req.params.id)         //...1
  next()
}, function(req,res,next) {
   res.send('User Info')                   // ...2
})

app.get('/user/:id', function(req,res,next){  //...3
   res.end(req.params.id)
})
```

- 실행 순서

: 첫 번째 라우트에 있는 첫 번째 미들웨어1 실행

 —> next함수가 호출되면 다음에 있는 미들웨어 2 실행

 —> 두 번째 미들웨어에 next함수 호출이 없으므로 해당 경로에 대한 라우팅을 종료, 두 번째 라우트에 있는 미들웨어3은 실행되지 않음. 

경우2)조건문 이용

```jsx

app.use('/user/:id', function(req,res,next){
  // 사용자 id가 0이면 나머지 미들웨어 호출 생략
  if (req.params.id==='0') next('route')         //...1
  //사용자 if가 0이 아니면 다음 미들웨어 호출
  else next()
}, function(req,res,next) {
   res.send('regular')                   // ...2
})

app.get('/user/:id', function(req,res,next){  //...3
   res.send('special')
})
```

- 실행 순서

: 사용자가 /user/:id경로에 접속하면 첫 번째 라우트에 있는 미들웨어1이 실행

—> if문에서 요청 객체 req에 있는 params.id값이 0이면 next(’route’)는다음 라우트의 미들웨어를 실행하라는 뜻으로 /user/:id에 대한 두 번째 라우트에 있는 미들웨어3이 실행

—>params.id값이 0이 아니면 인자가 없는 next()를 호출하여 다음 미들웨어 2가 실행

 

## 12 정적인 파일의 서비스

미들웨어를 사용하여 정적인 파일을 서비스하는 방법 Express버전으로 보기

정적인 파일: 웹 브라우저로 내려받는 이미지나, 자바스크립트, CSS같은 파일 의미

애플리케이션에서 정적인 파일을 서비스하게 허용하고 설정해야 함.

(익스프레스 홈페이지의 Getting started메뉴 중 Static files 부분 참고)

Express 디렉터리 아래에 public디렉터리 만들고 아래에 images디렉터리 만들어 hello.jpg 넣고 

```jsx
app.use(express.static('public'));//디렉터리에서 정적인 파일 찾기
```

—> [localhost:3000/images/hello.jpg](http://localhost:3000/images/hello.jpg) 접속하면 이미지 출력됨.

홈 화면에 이미지 출력하도록 main.js 수정

```jsx
app.use(express.static('public'));//디렉터리에서 정적인 파일 찾기

app.get('/', function(request,response){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(request.list);
            var html = template.HTML(title, list,
                `
                <h2>${title}</h2><p>${description}
                <img src="/images/hello.jpg" style="width:300px; display:black; margin-top:10px;">
                `,
                `<a href="/create">create</a>`
            );
            response.send(html);
});
```

- <img>태그를 이용하여 images디렉터리에 있는 hello.jpg이미지를 홈 화면에 표시
- src속성 이후의 내용은 CSS문법, style속성에 이미지를 어떻게 표시할 것인지 설정하는 디자인적인 요소 기술

⇒ **정적인 파일을 서비스할 때: 해당 파일이 있는 디렉터리를 express.static 메서드에 지정해서 app.use를 사용하면 됨.**

URL을 통해 해당 디렉터리에 있는 파일이나 디렉터리에 접근 가능, express.static메서드에 지정한 디렉터리 외에는 접근할 수 없게 하는 보안 기능도 갖춰짐.

## 13 에러 처리

**존재하지 않는 페이지를 요청했을 때 에러 처리)**

```jsx
//수정전 
app.post('/delete_process',function(request,response){
            var post = request.body;   
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
    });
    
//수정후
//404 에러를 처리하는 코드 추가
app.post('/delete_process',function(request,response){
            var post = request.body;   
            var id = post.id;
            var filteredId = path.parse(id).base;
            fs.unlink(`data/${filteredId}`, function(error) {
                response.redirect('/');
            });
        });

    app.use(function(req,res,next){
        res.status(404).send('Sorry cant find that!');
    });

```

- [localhost:3000/asdfasdfa](http://localhost:3000/asdfasdfa) 와 같이 사용자 요청에 응답할 페이지를 찾지 못하면 최종적으로 에러를 응답.
- req객체에 있는 status메서드에 404에러 코드를 전달하고 이때 전송할 메시지를 지정.

**글 목록에서 글을 선택해서 상세 보기 페이지에 접근할 때 존재하지 않는 페이지에 대응하는 에러 처리)**

```jsx
//수정전
app.get('/page/:pageId',function(request,response) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/create">create</a>
                <a href="/update/${sanitizedTitle}">update</a>
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
    });
}); 

//수정후
app.get('/page/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){ // 에러가 있다면 이 조건문을 만족할 것.--> if문 안에서는 next(err)코드로 다음 미들웨어에 에러를 전달함. 
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/create">create</a>
                <a href="/update/${sanitizedTitle}">update</a>
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
        }
    });
});

```

- http://localhost:3000page/CSS1주소에 접속하면 CSS1페이지가 없음에도에러 처리가 되지 않음. —> 페이지가 없는 경우에는 에러를 발생시키는 편이 더 좋음.
- 사용자가 요청한 파일 이름(filteredId)과 같은 이름의 파일을 data디렉터리에서 찾아서 보여줬음. fs.readFile로 파일을 읽을 때 실패하면 콜백 함수의 첫 번째 매개변수인 err에 에러 객체가 전달되게 약속돼 있음. —> err에 따라 분기하는 코드를 작성함으로써 파일 읽기에 실패했을 때 에러를 처리할 수 있음.
- next()에 아무런 값을 지정하지 않으면 정상적인 상황이고, 다음 미들웨러를 호출할 것
- next(’route’)와 같이 인자로 route를 전달하는 경우를 제외하고 next함수에 인자를 전달하면 익스프레스는   에러가 발생한 것으로 간주 —> next(err)는 에러를 전달하는 것
- 에러가 발생하지 않는다면 else문에 있는 코드를 실행할 것이므로 기존 코드를 else문 안으로 그대로 씀.

에러 메시지가 출력하는 정보 제어하기 위해 코드 추가 

```jsx
app.use(function(req,res,next){
        res.status(404).send('Sorry cant find that!');
    });

**//에러 메시지가 출력하는 정보 제어하기
app.use(function(err,req,res,next){
    console.error(err.stack)
    res.status(500).send('Something broke!')
});**

app.listen(3000,function() {
    console.log('Example app listening on port 3000')
});
```

- 에러 핸들러를 위한 미들웨어는 다른 미들웨어와 다르게 매개변수가 4개임 —> **매개변수가 4개이면 익스프레스 프레임워크는 에러 핸들러로 인식.**
- next함수로 미들웨어를 호출할 때 인자를 전달하면 첫 번째 매개변수인 err에 전달됨.

## 14 라우터

애플리케이션의 규모가 커지면 복잡도를 관리해야 함. 라우터가 아주 많아진다면 라우트를 파일로 만들어야 함.

### 라우터-주소 체계 변경

방법 설명: 익스프레스 홈페이지→ Guide메뉴→ Routing→ express.Router에 접속

- 상세보기 페이지를 라우팅하는 부분 수정

```jsx
//기존에page로 된 경로를 topic으로 변경
app.get('/topic/:pageId',function(request,response,next) {    // /page--> /topic으로 변
        var filteredId = path.parse(request.params.pageId).base; 
```

- [localhost:3000/page/CSS](http://localhost:3000/page/CSS) 접속하면 에러
- [localhost:3000/topic/CSS접속](http://localhost:3000/topic/CSS접속해야)하면 정상 접속됨
- 글 목록을 클릭해도 page가 아닌 topic으로 연결해야 하므로 template.js파일 수정

```jsx
<li><a href="/topic/${filelist[i]}">${filelist[i]}</a></li> // /page-->/topic으로 경
```

- main.js도 수정

```jsx

// 홈페이지에 있는 create링크의 주소 변경
app.get('/', function(request,response){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(request.list);
            var html = template.HTML(title, list,
                `
                <h2>${title}</h2><p>${description}
                <img src="/images/hello.jpg" style="width:300px; display:black; margin-top:10px;">
                `,
                `<a href="**/topic**/create">create</a>` //이부분 
            );
            response.send(html);
});

//페이지 생성에 진입하는부분의 주소 변경
app.get('**/topic**/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="**/topic**/create">create</a> // 이부분
                <a href="**/topic**/update/${sanitizedTitle}">update</a> // 이부분
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>` 
                
 //create 링크를 클릭했을 때(글 생성 페이지)의 라우트 주소 변경
app.get('**/topic**/create',function(request,response){ // 이부분 
```

**문제) create버튼을 누르면 에러가 발생**

**—> 우리가 원하는 것은 data디렉터리에서 create에 해당하는 페이지를 여는게 아니라, create가 특별한 페이지기 때문에 일종의 예약어로서 사용하고 싶은 것.**

**해결)**

**수정1:** /topic/create라우트, /topic/create_process라우트를 /topic/:pageId라우트 위로 이동, 글 생성 페이지, 글 생성 처리 관련 라우트 수정

```jsx
// 새 글을 작성하는 페이지 구현
app.get('**/topic**/create',function(request,response){
    var title = 'WEB - create';
    var list = template.list(request.list);
    var html = template.HTML(title, list, `
        <form action="**/topic**/create_process" method="post">
            <p><input type="text" name="title" placeholder="title"></p>
            <p>
                <textarea name="description" placeholder="description"></textarea>
            </p>
            <p>
                <input type="submit">
            </p>
        </form>
    `, '');
    response.send(html);
});

//새 글을 생성하는 create_process구현
app.post('**/topic**/create_process', function(request, response){
    console.log(request.list);
        var post = request.body;
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
          response.writeHead(302, {Location: `/?id=${title}`});
          response.end();
        });
  });

//app.get('/page',function(req,res) {res.send('/page')}); 
app.get('/topic/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/topic/create">create</a>
                <a href="/topic/update/${sanitizedTitle}">update</a>
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
        }
    });
});

```

—>글을 생성하는 페이지의 라우트 부분이 상세 보기 페이지의 라우트보다 먼저 나와야 함. /topic/create 라우트가 먼저 실행된 후에는 /topic/:pageId 라우트가 실행되지 않기 때문에 data디렉터리에 create에 해당하는 페이지가 없어도 에러가 발생하지 않을 것.

**수정2:** /topic/update라우트, /topic/update_process라우트를 /topic/:pageId라우트 위로 이동, 글 수정 페이지, 글 수정 처리 관련 라우트 수정, filelist→request.list로 변경

```jsx
  //글을 수정하는 페이지 구현
  app.get('**/topic**/update/:pageId',function(request,response){
    var filteredId = path.parse(request.params.pageId).base;
    fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
        var title = request.params.pageId;
        var list = template.list(**request.list**);
        var html = template.HTML(title, list,
            `
            <form action="**/topic**/update_process" method="post">
                <input type="hidden" name="id" value="${title}">
                <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                <p>
                    <textarea name="description" placeholder="description">${description}</textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
            `,
            `<a href="**/topic**/create">create</a> <a href="**/topic**/update?id=${title}">update</a>`
        );
        response.send(html);
    });
});

//글을 수정하는 update_process구현
app.post('**/topic**/update_process',function(request,response){
    var post = request.body;
    var id = post.id;
    var title = post.title;
    var description = post.description;
    fs.rename(`data/${id}`, `data/${title}`, function(error) {
        fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
            response.writeHead(302, {Location: `/?id=${title}`});
            response.end();
        });
    });
});

//app.get('/page',function(req,res) {res.send('/page')}); 
app.get('/topic/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/topic/create">create</a>
                <a href="/topic/update/${sanitizedTitle}">update</a>
                <form action="/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
        }
    });
});

```

**수정3:** 페이지를 수정한 다음, 수정한 페이지로 이동하도록 /topic/create_process라우트에서 리다이렉트하는 부분 수정 , 글 생성 후 리다이렉트하는 부분도 수정 

```jsx
//수정전
app.post('/topic/update_process',function(request,response){
    var post = request.body;
    var id = post.id;
    var title = post.title;
    var description = post.description;
    fs.rename(`data/${id}`, `data/${title}`, function(error) {
        fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
            **response.writeHead(302, {Location: `/?id=${title}`});
            response.end();**
        });
    });
});

//수정후
// 글 생성 후 리다이렉트하는 주소를 변경 
app.post('/topic/create_process', function(request, response){
        var post = request.body;
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
            response.redirect(`/topic/${title}`); // 글을 생성하면 Welcome페이지가 아닌 생성한 글의 상세 페이지로 이동 
        });
  });
//글 수정 후 리다이렉트하는 주소를 변경  
app.post('/topic/update_process',function(request,response){
    var post = request.body;
    var id = post.id;
    var title = post.title;
    var description = post.description;
    fs.rename(`data/${id}`, `data/${title}`, function(error) {
        fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
            **response.redirect(`/topic/${title}`);**
        });
    });
}); 
```

**수정4:** /topic/delete_process라우트를 /topic/:pageId라우트 위로 이동, 상세보기 페이지에서 삭제 버튼의 경로도 수정 

```jsx
// 글을 삭제하는 delete_process구현
app.post('**/topic**/delete_process',function(request,response){
    var post = request.body;   
    var id = post.id;
    var filteredId = path.parse(id).base;
    fs.unlink(`data/${filteredId}`, function(error) {
        response.redirect('/');
    });
});

//app.get('/page',function(req,res) {res.send('/page')}); 
app.get('/topic/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/topic/create">create</a>
                <a href="/topic/update/${sanitizedTitle}">update</a>
                <form action="**/topic**/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
        }
    });
});
```

수정된 main.js 전체

```jsx

var express=require('express')
var app=express()
var fs = require('fs');
var template = require('./lib/template.js');
var path = require('path');
var sanitizeHtml = require('sanitize-html');
var qs = require('querystring');
var bodyParser = require('body-parser'); //body-parser 모듈 불러오기
var compression = require('compression'); //compression 모듈 불러오기

app.use(bodyParser.urlencoded({extended:false})); // 익스프레스의 use메서드에 body-parser라는 미들웨어 전달 --> 해당 미들웨어가 실행되고 그 결과를 전달받음.
app.use(compression());
app.use(express.static('public'));//디렉터리에서 정적인 파일 찾기

app.get('*',function(request,response,next) {
    fs.readdir('./data',function(error,filelist){ // 데이터 디렉토리에 있는 파일 목록을 가져와서 파일리스트라는 변수가 세팅이 되고 function이 호출이 됨.
        request.list = filelist; //request객체에 list라는 변수를 filelist값으로 줄 것.
        next(); // 그다음에 호출되어야 할 미들웨어가 담겨있음. 
    });
});

//app.get('/',function(req,res) {res.send('Hello World!')}); // 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/', function(request,response){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(request.list);
            var html = template.HTML(title, list,
                `
                <h2>${title}</h2><p>${description}
                <img src="/images/hello.jpg" style="width:300px; display:black; margin-top:10px;">
                `,
                `<a href="/topic/create">create</a>`
            );
            response.send(html);
});

// 새 글을 작성하는 페이지 구현
app.get('/topic/create',function(request,response){
    var title = 'WEB - create';
    var list = template.list(request.list);
    var html = template.HTML(title, list, `
        <form action="/topic/create_process" method="post">
            <p><input type="text" name="title" placeholder="title"></p>
            <p>
                <textarea name="description" placeholder="description"></textarea>
            </p>
            <p>
                <input type="submit">
            </p>
        </form>
    `, '');
    response.send(html);
});

//새 글을 생성하는 create_process구현
app.post('/topic/create_process', function(request, response){
        var post = request.body;
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
            response.redirect(`/topic/${title}`);
        });
  });

  //글을 수정하는 페이지 구현
  app.get('/topic/update/:pageId',function(request,response){
    var filteredId = path.parse(request.params.pageId).base;
    fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
        var title = request.params.pageId;
        var list = template.list(request.list);
        var html = template.HTML(title, list,
            `
            <form action="/topic/update_process" method="post">
                <input type="hidden" name="id" value="${title}">
                <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                <p>
                    <textarea name="description" placeholder="description">${description}</textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
            `,
            `<a href="/topic/create">create</a> <a href="/topic/update?id=${title}">update</a>`
        );
        response.send(html);
    });
});

//글을 수정하는 update_process구현
app.post('/topic/update_process',function(request,response){
    var post = request.body;
    var id = post.id;
    var title = post.title;
    var description = post.description;
    fs.rename(`data/${id}`, `data/${title}`, function(error) {
        fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
            response.redirect(`/topic/${title}`);
        });
    });
});

// 글을 삭제하는 delete_process구현
app.post('/topic/delete_process',function(request,response){
    var post = request.body;   
    var id = post.id;
    var filteredId = path.parse(id).base;
    fs.unlink(`data/${filteredId}`, function(error) {
        response.redirect('/');
    });
});

//app.get('/page',function(req,res) {res.send('/page')}); 
app.get('/topic/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/topic/create">create</a>
                <a href="/topic/update/${sanitizedTitle}">update</a>
                <form action="/topic/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
        }
    });
});

app.use(function(req,res,next){
    res.status(404).send('Sorry cant find that!');
    });

//에러 메시지가 출력하는 정보 제어하기
app.use(function(err,req,res,next){
    console.error(err.stack)
    res.status(500).send('Something broke!')
});

app.listen(3000,function() {
    console.log('Example app listening on port 3000')
});
```

### 라우터- 파일로 분리

익스프레스의 라우터 기능을 이용하여 코드 정리 정돈

express디렉터리 아래에 routes라는 디렉터리 만들고 거기에 topic.js파일 만들기 

express/routes/topic.js

```jsx
**var express = require('express'); // 익스프레스 모듈을 불러오기
var router = express.Router(); 
// 이 모듈에서 Router()메서드를 호출해서 router객체를 얻음, express.Router()메서드는 router객체를 리턴하게 약속돼 있음, app.get()이아닌 router.get()을 호출해야 함. 
// --> 따라서 app.get()이라고 된 부분을 모두 router.get()으로 고침.
var path = require('path');
var fs = require('fs');
var sanitizeHtml = require('sanitize-html');
var template = require('../lib/template.js');**

// 새 글을 작성하는 페이지 구현
router.get('/create',function(request,response){
    var title = 'WEB - create';
    var list = template.list(request.list);
    var html = template.HTML(title, list, `
        <form action="/topic/create_process" method="post">
            <p><input type="text" name="title" placeholder="title"></p>
            <p>
                <textarea name="description" placeholder="description"></textarea>
            </p>
            <p>
                <input type="submit">
            </p>
        </form>
    `, '');
    response.send(html);
});

//새 글을 생성하는 create_process구현
router.post('/create_process', function(request, response){
        var post = request.body;
        var title = post.title;
        var description = post.description;
        fs.writeFile(`data/${title}`, description, 'utf8', function(err){
            response.redirect(`/topic/${title}`);
        });
  });

  //글을 수정하는 페이지 구현
  router.get('/update/:pageId',function(request,response){
    var filteredId = path.parse(request.params.pageId).base;
    fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
        var title = request.params.pageId;
        var list = template.list(request.list);
        var html = template.HTML(title, list,
            `
            <form action="/topic/update_process" method="post">
                <input type="hidden" name="id" value="${title}">
                <p><input type="text" name="title" placeholder="title" value="${title}"></p>
                <p>
                    <textarea name="description" placeholder="description">${description}</textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
            `,
            `<a href="/topic/create">create</a> <a href="/topic/update?id=${title}">update</a>`
        );
        response.send(html);
    });
});

//글을 수정하는 update_process구현
router.post('/update_process',function(request,response){
    var post = request.body;
    var id = post.id;
    var title = post.title;
    var description = post.description;
    fs.rename(`data/${id}`, `data/${title}`, function(error) {
        fs.writeFile(`data/${title}`, description, 'utf8', function(err) {
            response.redirect(`/topic/${title}`);
        });
    });
});

// 글을 삭제하는 delete_process구현
router.post('/delete_process',function(request,response){
    var post = request.body;   
    var id = post.id;
    var filteredId = path.parse(id).base;
    fs.unlink(`data/${filteredId}`, function(error) {
        response.redirect('/');
    });
});

//app.get('/page',function(req,res) {res.send('/page')}); 
router.get('/:pageId',function(request,response,next) {
        var filteredId = path.parse(request.params.pageId).base;
        fs.readFile(`data/${filteredId}`, 'utf8', function(err, description) {
            if(err){
                next(err);
            }else{
            var title = request.params.pageId;
            var sanitizedTitle = sanitizeHtml(title);
            var sanitizedDescription = sanitizeHtml(description, {
                allowedTags:['h1']
            });
            var list = template.list(request.list);
            var html = template.HTML(sanitizedTitle, list,
                `<h2>${sanitizedTitle}</h2><p>${sanitizedDescription}</p>`,
                `<a href="/topic/create">create</a>
                <a href="/topic/update/${sanitizedTitle}">update</a>
                <form action="/topic/delete_process" method="post">
                    <input type="hidden" name="id" value="${sanitizedTitle}">
                    <input type="submit" value="delete">
                </form>`
            );
            response.send(html);
        }
    });
});
module.exports = router; // 모듈로서 동작하게 router를 익스포트 
```

- main.js에서 /topic으로 시작하는 요청에 대해 topicRouter를 적용했는데, topic.js에서 또 다시 /topic이 나오기 때문에 **topic.js에서는 /topic부분을 지워야 함.**

main.js에 코드 추가 

```jsx
var topicRouter =  require('./reoutes/topic');
// topicRouter객체 생성 및 topic.js파일 불러오기 

app.use('/topic',topicRouter); 
// topicRouter 적용하는 코드: /topic으로 시작하는 주소에 topicRouter라는 이름의 미들웨어 적용하겠다는 의미.

```

**⇒ topic.js와 main.js에서 모듈 불러오는 코드의 차이**

topic.js: express가 가지고 있는 Router()메서드를 호출, express()는 애플리케이션 객체를 리턴하게 약속돼 있고, Router()메서드는 router객체를 리턴하게 약속돼 있음. 

main.js: express()모듈 자체를 출력

수정된 main.js 전체

```jsx

var express=require('express')
var app=express()
var fs = require('fs');
var template = require('./lib/template.js');
var path = require('path');
var sanitizeHtml = require('sanitize-html');
var qs = require('querystring');
var bodyParser = require('body-parser'); //body-parser 모듈 불러오기
var compression = require('compression'); //compression 모듈 불러오기
var topicRouter =  require('./routes/topic');// topicRouter객체 생성 및 topic.js파일 불러오기 

app.use(express.static('public'));//디렉터리에서 정적인 파일 찾기
app.use(bodyParser.urlencoded({extended:false})); // 익스프레스의 use메서드에 body-parser라는 미들웨어 전달 --> 해당 미들웨어가 실행되고 그 결과를 전달받음.
app.use(compression());

app.get('*',function(request,response,next) {
    fs.readdir('./data',function(error,filelist){ // 데이터 디렉토리에 있는 파일 목록을 가져와서 파일리스트라는 변수가 세팅이 되고 function이 호출이 됨.
        request.list = filelist; //request객체에 list라는 변수를 filelist값으로 줄 것.
        next(); // 그다음에 호출되어야 할 미들웨어가 담겨있음. 
    });
});

app.use('/topic',topicRouter); // topicRouter 적용하는 코드: /topic으로 시작하는 주소에 topicRouter라는 이름의 미들웨어 적용하겠다는 의미.

//app.get('/',function(req,res) {res.send('Hello World!')}); // 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/', function(request,response){
            var title = 'Welcome';
            var description = 'Hello, Node.js';
            var list = template.list(request.list);
            var html = template.HTML(title, list,
                `
                <h2>${title}</h2><p>${description}
                <img src="/images/hello.jpg" style="width:300px; display:black; margin-top:10px;">
                `,
                `<a href="/topic/create">create</a>`
            );
            response.send(html);
});

app.use(function(req,res,next){
    res.status(404).send('Sorry cant find that!');
    });

//에러 메시지가 출력하는 정보 제어하기
app.use(function(err,req,res,next){
    console.error(err.stack)
    res.status(500).send('Something broke!')
});

app.listen(3000,function() {
    console.log('Example app listening on port 3000')
});

```

### 라우터- 파일로 분리-index

홈 분리해보기

routes디렉터리 아래에 index.js파일 만들기

express/routes/index.js에 홈 부분의 코전

```jsx
//app.get('/',function(req,res) {res.send('Hello World!')}); // 사용자가 홈에 접속했을 때 응답하는 코드
app.get('/', function(request,response){
    var title = 'Welcome';
    var description = 'Hello, Node.js';
    var list = template.list(request.list);
    var html = template.HTML(title, list,
        `
        <h2>${title}</h2><p>${description}
        <img src="/images/hello.jpg" style="width:300px; display:black; margin-top:10px;">
        `,
        `<a href="/topic/create">create</a>`
    );
    response.send(html);
});

```

index.js 수정 

```jsx
var express = require('express');
var router = express.Router();
var template = require('../lib/template.js');

router.get('/', function(request,response){
    var title = 'Welcome';
    var description = 'Hello, Node.js';
    var list = template.list(request.list);
    var html = template.HTML(title, list,
        `
        <h2>${title}</h2><p>${description}
        <img src="/images/hello.jpg" style="width:300px; display:black; margin-top:10px;">
        `,
        `<a href="/topic/create">create</a>`
    );
    response.send(html);
});
module.exports=router;
```

- 필요한 모듈 불러오기 및 모듈로 정의
- app객체를 router객체로 변경
- 다른 파일에서 사용할 수 있게 모듈로 정의

main.js 수정 

```jsx

var express=require('express')
var app=express()
var fs = require('fs');
var bodyParser = require('body-parser'); //body-parser 모듈 불러오기
var compression = require('compression'); //compression 모듈 불러오기

var topicRouter =  require('./routes/topic');// topicRouter객체 생성 및 topic.js파일 불러오기 
var indexRouter = require('./routes/index');//indexRouter객체 생성 및 index.js 파일 불러오기 

app.use(express.static('public'));//디렉터리에서 정적인 파일 찾기
app.use(bodyParser.urlencoded({extended:false})); // 익스프레스의 use메서드에 body-parser라는 미들웨어 전달 --> 해당 미들웨어가 실행되고 그 결과를 전달받음.
app.use(compression());

app.get('*',function(request,response,next) {
    fs.readdir('./data',function(error,filelist){ // 데이터 디렉토리에 있는 파일 목록을 가져와서 파일리스트라는 변수가 세팅이 되고 function이 호출이 됨.
        request.list = filelist; //request객체에 list라는 변수를 filelist값으로 줄 것.
        next(); // 그다음에 호출되어야 할 미들웨어가 담겨있음. 
    });
});

app.use('/', indexRouter); //indexRouter 적용하는 코드 : main.js파일에서 index.js파일을 불러와 indexRouter객체에 저장하고 이를 미들웨어로 사용하는 코드  
app.use('/topic',topicRouter); // topicRouter 적용하는 코드: /topic으로 시작하는 주소에 topicRouter라는 이름의 미들웨어 적용하겠다는 의미.

app.use(function(req,res,next){
    res.status(404).send('Sorry cant find that!');
    });

//에러 메시지가 출력하는 정보 제어하기
app.use(function(err,req,res,next){
    console.error(err.stack)
    res.status(500).send('Something broke!')
});

app.listen(3000,function() {
    console.log('Example app listening on port 3000')
});
```

- template과 qs모듈은 더 이상 필요하지 않으므로 지움.

⇒ main.js파일은 최대한 가볍게 유지하는게 좋음.

## 15 보안

**보안과 관련된 지침**

1. **익스프레스 버전을 최신으로 유지**
2. **TLS사용:** HTTP와 HTTPS 프로토콜 중에서 보안이 강화된 HTTPS 프로토콜을 사용하라는 의미. 

: HTTPS를 사용하면 웹 서버와 웹 브라우저가 통신할 때 서로 암호화해서 사용하기 떄문에 중간에 누군가가 데이터를 가로채더라도 데이터의 실제 내용을 알 수 없게 만들 수 있음

: 웹 사이트의 도메인 등을 변조하는 피싱을 하더라도 인증서를 통해 이를 알아차릴 수 있게 경고 메시지를 띄울 수 있음.

1. **Helmet모듈 사용:** 자주 발생하는 보안과 관련된 이슈를 자동으로 해결하는 모듈

: 설치 > npm install  - -save helmet

1. **쿠키를 안전하게 사용:** 웹 사이트에 사용자가 방문할 때 누가 방문했는지 확인하려면 방문자 한 명 한 명을 식별할 필요가 있음. 이때 사용하는 메커니즘이 쿠키임.
2. **종속 모듈이 안전한지 확인:** 웹 애플리케이션이 사용하는 여러 모듈에 취약점이 있는지 확인하라는 의미. nsp라는 모듈을 사용하여 취약점 검사가 가능.

: 설치> npm i nsp -g    // -g는 컴퓨터 전체에서 사용할 수 있게 설치한다는 의미 

: 실행> nsp check  // nsp가 우리 애플리케이션의 package.json파일에서 dependencies항목에 나열된 모듈을 검사해서 취약점이 있는지 확인 

1. **추가적인 고려사항**
2. **그외의 알려진 취약점 회피**

## 16 익스프레스 제너레이터

: 프로젝트를 할 때마다 반복되는 작업을 좀 더 쉽게 할 수 있게 기본적이면서 모범적인 프로젝트 구성을 지원하는 기능 

사용법: 익스프레스 공식 홈페이지→ [Getting started]→ [Express generator]에서 확인

설치: 

```jsx
> mkdir gen // 현재의 디렉터리에 설치하면 프로젝트가 날아갈 수도 있으므로 gen이라는 새로운 디렉터리를 만들기 

> cd gen // gen 디렉터리로 이동 

>npm install express -generator -g // 설치 

>express -h // 익스프레스 제너레이터를 어떻게 사용하는지 예가 나옴.

> express myapp // 익스프레스 제너레이터를 이용하여 프로젝트 시작하기
```

⇒ gen 디렉터리 아래에 myapp디렉터리가 생성되고, myapp디렉터리에 bin, public, routes,views디렉터리와 app.js, package.json파일이 생성됨.

⇒ package.json파일에 익스프레스를 이용하여 웹 프로젝트를 만드는 데 기본적으로 필요한 라이브러리가 나옴.

```jsx
> cd myapp //myapp디렉터리로 이동
> npm install // package.json파일에서 dependencies에 정의된 항목을 보고, node_modules에 내려받게 약속되어 있음.

> npm start //애플리케이션 실행
--> 웹 브라우저엣 3000번 포트로 접속해보면 routes디렉터리 아래에 있는 index.js파일이 열림  
```

express/gen/myapp/app.js

```jsx
// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');
```

—> views디렉터리 아래에 있는 jade라는 확장자를 가진 파일들을 가리키는데, jade는 HTML코드를 좀 더 적은 코드로 생성해주는 문법

—> app.ks파일에 static파일을 생성하는 부분이나 필요한 라우터를 설정하는 부분, 404에러를 처리하는 부분, 기타 에러를 처리하는 코드 등이 기본으로 작성돼 있음.  

⇒ 익스프레스 제너레이터는 이러한 기본 구성을 바탕으로 프로젝트

## 17 수업을 마치며…

### 템플릿 엔진)

:웹 애플리케이션 개발에서 HTML을 생성하는 작업을 더 쉽고 효율적으로 만들어주는 도구 

:HTML파일에 동적 데이터를 쉽게 삽입하고, 반복적인 구조를 간편하게 생성할 수 있음.

### 퍼그(pug))

:익스프레스와 함께  자주 사용되는 템플릿 엔진 중 하나

: 조금 더 적은 코드를 이용하여 더 많은 HTML코드를 생성할 수 있고 반복문을 이용하여 HTML코드를 작성할 수 있음.

: 조건문이나 include를 이용ㅎ여 퍼그로 만든 다른 코드를 읽어올 수 있고,  생산성을 높여주는 상속 프로그래밍 기법도 지원함.

- 익스프레스에서 미들웨어가 매우 중요한 개념임. 여러 미들웨어 중에서 어떤 미들웨어를 사용할 수 있느냐에 따라 일이 편리해짐

템플릿 엔진 사용: 익스프레스 홈페이지→[Guide]메뉴→ [Using template engines]에 있는 내용 보기
